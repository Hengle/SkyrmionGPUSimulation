// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWStructuredBuffer<float3> magneticMomentum;
RWTexture2D<float4> magneticMomentumX;
RWTexture2D<float4> magneticMomentumY;
RWTexture2D<float4> magneticMomentumZ;

Texture2D<float4>  boundaryCondition;
Texture2D<float4>  exchangeStrength;
Texture2D<float4>  jxPeroidFunction;

uint2 size;
float K;
float D;
float D0;
float B;
float alpha;
float timestep;
uint jxstep;
uint jxperoid;

//(0,0) is left buttom corner!
//only change the name up to down, the result is unchanged...
[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 zero3 = float3(0.0f, 0.0f, 0.0f);

    float3 s = float3(magneticMomentumX[id.xy].x, magneticMomentumY[id.xy].x, magneticMomentumZ[id.xy].x);

    float3 sleft    = id.x > 1 ? float3(magneticMomentumX[id.xy - uint2(1, 0)].x, magneticMomentumY[id.xy - uint2(1, 0)].x, magneticMomentumZ[id.xy - uint2(1, 0)].x) : zero3;
    float3 sright   = id.x < (size.x - 1) ? float3(magneticMomentumX[id.xy + uint2(1, 0)].x, magneticMomentumY[id.xy + uint2(1, 0)].x, magneticMomentumZ[id.xy + uint2(1, 0)].x) : zero3;
    float3 sdown    = id.y > 1 ? float3(magneticMomentumX[id.xy - uint2(0, 1)].x, magneticMomentumY[id.xy - uint2(0, 1)].x, magneticMomentumZ[id.xy - uint2(0, 1)].x) : zero3;
    float3 sup      = id.y < (size.y - 1) ? float3(magneticMomentumX[id.xy + uint2(0, 1)].x, magneticMomentumY[id.xy + uint2(0, 1)].x, magneticMomentumZ[id.xy + uint2(0, 1)].x) : zero3;

    float edge = boundaryCondition[id.xy].r > 0.5f ? 1.0f : 0.0f;

    float j_s       = exchangeStrength[id.xy].x;
    float j_left    = id.x > 1 ? exchangeStrength[id.xy - uint2(1, 0)].x : 0.0f;
    float j_down    = id.y > 1 ? exchangeStrength[id.xy - uint2(0, 1)].x : 0.0f;

    float d_s       = D0 + D * j_s;
    float d_left    = id.x > 1 ? (D0 + D * j_left) : 0.0f;
    float d_down    = id.y > 1 ? (D0 + D * j_down) : 0.0f;

    float3 vright   = float3(1.0, 0.0, 0.0);
    float3 vup      = float3(0.0, 1.0, 0.0);

    float3 beff = (j_left * sleft + j_s * sright + j_down * sdown + j_s * sup)
        + (d_s * cross(sright, vright) - d_left * cross(sleft, vright) + d_s * cross(sup, vup) - d_down * cross(sdown, vup))
        + float3(0.0f, 0.0f, B) + 2.0 * K * float3(0.0f, 0.0f, s.z);

    jxstep++;
    float jx = jxperoid > 0 ? jxPeroidFunction[uint2(jxstep % jxperoid, 0)].x : 0.0f;
    float3 stt = -jx * cross(s, cross((sright - sleft) * 0.5f, s));

    float3 newS = cross(s, beff) + stt;
    newS = (newS - alpha * cross(s, newS)) / (1 + alpha * alpha);

    float3 retColor = edge < 0.5f ? zero3 : normalize(s + timestep * newS);

    magneticMomentumX[id.xy] = float4(retColor.x * edge, 0.0f, 0.0f, 1.0f);
    magneticMomentumY[id.xy] = float4(retColor.y * edge, 0.0f, 0.0f, 1.0f);
    magneticMomentumZ[id.xy] = float4(retColor.z * edge, 0.0f, 0.0f, 1.0f);
}
