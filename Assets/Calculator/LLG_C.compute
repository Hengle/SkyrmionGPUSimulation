// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWStructuredBuffer<float3> magneticMomentum;
RWTexture2D<float4> magneticMomentum;
Texture2D<float4>  boundaryCondition;
Texture2D<float4>  exchangeStrength;

uint2 size;
float K;
float D;
float B;
float jx;
float alpha;
float timestep;

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float4 zero4 = float4(0.5f, 0.5f, 0.5f, 1.0f);
    float3 s = magneticMomentum[id.xy].xyz;
    float3 sleft    = id.x > 1 ? magneticMomentum[id.xy - uint2(1, 0)].xyz : zero4.xyz;
    float3 sright   = id.x < (size.x - 1) ? magneticMomentum[id.xy + uint2(1, 0)].xyz : zero4.xyz;
    float3 sup      = id.y > 1 ? magneticMomentum[id.xy - uint2(0, 1)].xyz : zero4.xyz;
    float3 sdown    = id.y < (size.y - 1) ? magneticMomentum[id.xy + uint2(0, 1)].xyz : zero4.xyz;
    s = 2.0f * (s - 0.5f);
    sleft = 2.0f * (sleft - 0.5f);
    sright = 2.0f * (sright - 0.5f);
    sup = 2.0f * (sup - 0.5f);
    sdown = 2.0f * (sdown - 0.5f);

    float edge = boundaryCondition[id.xy].r > 0.5f ? 1.0f : 0.0f;

    float j_s       = exchangeStrength[id.xy].x;
    float j_left    = id.x > 1 ? exchangeStrength[id.xy - uint2(1, 0)].x : 0.0f;
    float j_up      = id.y > 1 ? exchangeStrength[id.xy - uint2(0, 1)].x : 0.0f;

    float3 vright    = float3(1.0, 0.0, 0.0);
    float3 vdown     = float3(0.0, 1.0, 0.0);

    float3 beff = (j_left * sleft + j_s * sright + j_up * sup + j_s * sdown)
        + D * (j_s * cross(sright, vright) - j_left * cross(sleft, vright) + j_s * cross(sdown, vdown) - j_up * cross(sup, vdown))
        + float3(0.0f, 0.0f, B) + 2.0 * K * float3(0.0f, 0.0f, s.z);

    float3 stt = -jx * cross(s, cross((sright - sleft) * 0.5f, s));

    float3 newS = cross(s, beff) + stt;
    newS = newS - alpha * cross(s, newS);

    float3 retColor = normalize(s + timestep * newS) * 0.5f + 0.5f;
    magneticMomentum[id.xy] = float4(retColor.r, retColor.g, retColor.b, 1.0f) * edge + (1.0f - edge) * zero4;
}
